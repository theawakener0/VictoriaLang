// ============================================================
// Victoria Language - DSA (Data Structures & Algorithms) Demo
// ============================================================
// This file demonstrates features useful for solving DSA problems
// and learning algorithms with deep understanding.

// ===================
// #make - Constants for Competitive Programming
// ===================

#make MAX_N 100000
#make MOD 1000000007
#make INF 999999999
#make EPSILON 0.00001

print("=== Constants Demo ===")
print("MAX_N = ${MAX_N}")
print("MOD = ${MOD}")
print("INF = ${INF}")

// ===================
// Enums - For State Management
// ===================

enum NodeState {
    UNVISITED,
    VISITING,
    VISITED
}

enum Direction {
    UP = 0,
    RIGHT = 1,
    DOWN = 2,
    LEFT = 3
}

print("\n=== Enum Demo ===")
print("NodeState.UNVISITED = 0")
print("NodeState.VISITING = 1")
print("Direction.RIGHT = ${Direction.RIGHT}")

// ===================
// Character Operations - Essential for String Problems
// ===================

print("\n=== Character Operations ===")

let ch = 'A'
print("Character: ${ch}")
print("ASCII value of 'A': ${ord('A')}")
print("Character from 65: ${chr(65)}")

// Character classification
print("\nisDigit('5'): " + string(isDigit('5')))
print("isDigit('a'): " + string(isDigit('a')))
print("isLetter('Z'): " + string(isLetter('Z')))
print("isAlpha('3'): " + string(isAlpha('3')))

// ===================
// Algorithm 1: Character Frequency Counter
// ===================

print("\n=== Algorithm: Character Frequency ===")

define countFrequency(s) {
    let freq = {}
    for i in 0..len(s) {
        let c = s[i]
        if (freq[c] == null) {
            freq[c] = 1
        } else {
            freq[c] = freq[c] + 1
        }
    }
    return freq
}

let text = "mississippi"
let freq = countFrequency(text)
print("Frequency of characters in '${text}':")
print(freq)

// ===================
// Algorithm 2: Check if Two Strings are Anagrams
// ===================

print("\n=== Algorithm: Anagram Check ===")

define isAnagram(s1, s2) {
    if (len(s1) != len(s2)) {
        return false
    }
    
    // Count characters (using array for a-z)
    let count = []
    for i in 0..26 {
        count = push(count, 0)
    }
    
    for i in 0..len(s1) {
        let c1 = ord(s1[i]) - ord('a')
        let c2 = ord(s2[i]) - ord('a')
        count[c1] = count[c1] + 1
        count[c2] = count[c2] - 1
    }
    
    for i in 0..26 {
        if (count[i] != 0) {
            return false
        }
    }
    return true
}

print("isAnagram('listen', 'silent'): " + string(isAnagram("listen", "silent")))
print("isAnagram('hello', 'world'): " + string(isAnagram("hello", "world")))

// ===================
// Algorithm 3: Palindrome Check
// ===================

print("\n=== Algorithm: Palindrome Check ===")

define isPalindrome(s) {
    let left = 0
    let right = len(s) - 1
    
    while (left < right) {
        // Skip non-alphanumeric characters
        while (left < right && !isAlpha(s[left])) {
            left++
        }
        while (left < right && !isAlpha(s[right])) {
            right--
        }
        
        if (toLower(s[left]) != toLower(s[right])) {
            return false
        }
        left++
        right--
    }
    return true
}

print("isPalindrome('racecar'): " + string(isPalindrome("racecar")))
print("isPalindrome('hello'): " + string(isPalindrome("hello")))

// ===================
// Algorithm 4: Binary Search
// ===================

print("\n=== Algorithm: Binary Search ===")

define binarySearch(arr, target) {
    let left = 0
    let right = len(arr) - 1
    
    while (left <= right) {
        let mid = left + (right - left) / 2
        
        if (arr[mid] == target) {
            return mid
        }
        if (arr[mid] < target) {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}

let sortedArr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
print("Array: ${sortedArr}")
print("binarySearch(arr, 7): index ${binarySearch(sortedArr, 7)}")
print("binarySearch(arr, 6): index ${binarySearch(sortedArr, 6)}")

// ===================
// Algorithm 5: Fibonacci with Memoization
// ===================

print("\n=== Algorithm: Fibonacci (Memoization) ===")

let memo = {}

define fib(n) {
    if (n <= 1) {
        return n
    }
    if (memo[n] != null) {
        return memo[n]
    }
    let result = fib(n - 1) + fib(n - 2)
    memo[n] = result
    return result
}

print("fib(10) = ${fib(10)}")
print("fib(20) = ${fib(20)}")
print("fib(30) = ${fib(30)}")

// ===================
// Algorithm 6: GCD using Euclidean Algorithm
// ===================

print("\n=== Algorithm: GCD (Euclidean) ===")

define gcd(a, b) {
    while (b != 0) {
        let temp = b
        b = a % b
        a = temp
    }
    return a
}

define lcm(a, b) {
    return (a * b) / gcd(a, b)
}

print("gcd(48, 18) = ${gcd(48, 18)}")
print("lcm(4, 6) = ${lcm(4, 6)}")

// ===================
// Algorithm 7: Prime Check
// ===================

print("\n=== Algorithm: Prime Check ===")

define isPrime(n) {
    if (n <= 1) {
        return false
    }
    if (n <= 3) {
        return true
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return false
    }
    
    let i = 5
    while (i * i <= n) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false
        }
        i = i + 6
    }
    return true
}

print("isPrime(17): " + string(isPrime(17)))
print("isPrime(18): " + string(isPrime(18)))
print("isPrime(97): " + string(isPrime(97)))

// ===================
// Algorithm 8: Sieve of Eratosthenes
// ===================

print("\n=== Algorithm: Sieve of Eratosthenes ===")

define sieve(n) {
    let isPrime = []
    for i in 0..(n + 1) {
        isPrime = push(isPrime, true)
    }
    isPrime[0] = false
    isPrime[1] = false
    
    let i = 2
    while (i * i <= n) {
        if (isPrime[i]) {
            let j = i * i
            while (j <= n) {
                isPrime[j] = false
                j = j + i
            }
        }
        i++
    }
    
    let primes = []
    for i in 2..(n + 1) {
        if (isPrime[i]) {
            primes = push(primes, i)
        }
    }
    return primes
}

let primes = sieve(50)
print("Primes up to 50: ${primes}")

// ===================
// Algorithm 9: Two Pointers - Two Sum (Sorted)
// ===================

print("\n=== Algorithm: Two Sum (Sorted Array) ===")

define twoSum(arr, target) {
    let left = 0
    let right = len(arr) - 1
    
    while (left < right) {
        let sum = arr[left] + arr[right]
        if (sum == target) {
            return [left, right]
        }
        if (sum < target) {
            left++
        } else {
            right--
        }
    }
    return [-1, -1]
}

let nums = [2, 7, 11, 15]
print("Array: ${nums}")
print("twoSum(arr, 9): ${twoSum(nums, 9)}")
print("twoSum(arr, 18): ${twoSum(nums, 18)}")

// ===================
// Algorithm 10: Merge Sort
// ===================

print("\n=== Algorithm: Merge Sort ===")

define merge(left, right) {
    let result = []
    let i = 0
    let j = 0
    
    while (i < len(left) && j < len(right)) {
        if (left[i] <= right[j]) {
            result = push(result, left[i])
            i++
        } else {
            result = push(result, right[j])
            j++
        }
    }
    
    while (i < len(left)) {
        result = push(result, left[i])
        i++
    }
    
    while (j < len(right)) {
        result = push(result, right[j])
        j++
    }
    
    return result
}

define mergeSort(arr) {
    if (len(arr) <= 1) {
        return arr
    }
    
    let mid = len(arr) / 2
    let left = mergeSort(arr[:mid])
    let right = mergeSort(arr[mid:])
    
    return merge(left, right)
}

let unsorted = [64, 34, 25, 12, 22, 11, 90]
print("Unsorted: ${unsorted}")
print("Sorted: ${mergeSort(unsorted)}")

// ===================
// Summary
// ===================

print("\n=== Summary ===")
print("Victoria provides powerful features for DSA:")
print("1. #make for compile-time constants (MAX_N, MOD, INF)")
print("2. enum for state management (graph traversal states)")
print("3. Character functions (ord, chr, isDigit, isLetter)")
print("4. Array slicing (arr[:mid], arr[mid:])")
print("5. First-class functions for clean algorithm implementation")
print("6. Hash maps for memoization and frequency counting")
print("\nHappy coding! ðŸš€")
